<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6. Discrete Mathematics &mdash; Mathematics in Lean 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. Structures" href="C07_Structures.html" />
    <link rel="prev" title="5. Elementary Number Theory" href="C05_Elementary_Number_Theory.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Mathematics in Lean
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="C01_Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="C02_Basics.html">2. Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="C03_Logic.html">3. Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="C04_Sets_and_Functions.html">4. Sets and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="C05_Elementary_Number_Theory.html">5. Elementary Number Theory</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. Discrete Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#more-induction">6.1. More Induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#finsets-and-fintypes">6.2. Finsets and Fintypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#counting-arguments">6.3. Counting Arguments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="C07_Structures.html">7. Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="C08_Hierarchies.html">8. Hierarchies</a></li>
<li class="toctree-l1"><a class="reference internal" href="C09_Groups_and_Rings.html">9. Groups and Rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="C10_Topology.html">10. Topology</a></li>
<li class="toctree-l1"><a class="reference internal" href="C11_Differential_Calculus.html">11. Differential Calculus</a></li>
<li class="toctree-l1"><a class="reference internal" href="C12_Integration_and_Measure_Theory.html">12. Integration and Measure Theory</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Mathematics in Lean</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">6. </span>Discrete Mathematics</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/C06_Discrete_Mathematics.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="discrete-mathematics">
<span id="id1"></span><h1><span class="section-number">6. </span>Discrete Mathematics<a class="headerlink" href="#discrete-mathematics" title="Permalink to this heading">&#61633;</a></h1>
<p><em>Discrete Mathematics</em> is the study of finite sets, objects, and structures.
We can count the elements of a finite set or we can consider a finite sum or product over its
elements.
We can iterate an operation over the elements of a finite structure.
We can also study objects that are generated by finitely many applications of
certain generating functions, we can define functions by structural recursion,
and prove theorems by structural induction.
The aim of this chapter is to survey parts of Mathlib that support all these types
of reasoning.</p>
<section id="more-induction">
<span id="id2"></span><h2><span class="section-number">6.1. </span>More Induction<a class="headerlink" href="#more-induction" title="Permalink to this heading">&#61633;</a></h2>
<p>In <a class="reference internal" href="C05_Elementary_Number_Theory.html#section-induction-and-recursion"><span class="std std-numref">Section 5.2</span></a> we saw how to define the factorial function by recursion on
the natural numbers.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">fac</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">fac</span> <span class="n">n</span>
</pre></div>
</div>
<p>We also saw how to prove theorems using the <code class="docutils literal notranslate"><span class="pre">induction'</span></code> tactic.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">fac_pos</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">fac</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction&#39;</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span>
  <span class="bp">&#183;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">fac</span><span class="o">]</span>
    <span class="n">exact</span> <span class="n">zero_lt_one</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fac</span><span class="o">]</span>
  <span class="n">exact</span> <span class="n">mul_pos</span> <span class="n">n.succ_pos</span> <span class="n">ih</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">induction</span></code> tactic (without the prime tick mark) allows for more structured syntax.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">fac</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span>
  <span class="n">case</span> <span class="n">zero</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">fac</span><span class="o">]</span>
    <span class="n">exact</span> <span class="n">zero_lt_one</span>
  <span class="n">case</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">fac</span><span class="o">]</span>
    <span class="n">exact</span> <span class="n">mul_pos</span> <span class="n">n.succ_pos</span> <span class="n">ih</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">fac</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">fac</span><span class="o">]</span>
    <span class="n">exact</span> <span class="n">zero_lt_one</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">fac</span><span class="o">]</span>
    <span class="n">exact</span> <span class="n">mul_pos</span> <span class="n">n.succ_pos</span> <span class="n">ih</span>
</pre></div>
</div>
<p>The names of the cases, <code class="docutils literal notranslate"><span class="pre">zero</span></code> and <code class="docutils literal notranslate"><span class="pre">succ</span></code>, are taken from the definition of the induction
principle.
Notice that the <code class="docutils literal notranslate"><span class="pre">succ</span></code> case allows you to choose whatever names you want for the
induction variable and the inductive hypothesis, here <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">ih</span></code>.
You can even use the same notation used to define a recursive function.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">fac_pos&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">fac</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">fac</span><span class="o">]</span>
      <span class="n">exact</span> <span class="n">zero_lt_one</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">fac</span><span class="o">]</span>
    <span class="n">exact</span> <span class="n">mul_pos</span> <span class="n">n.succ_pos</span> <span class="o">(</span><span class="n">fac_pos&#39;</span> <span class="n">n</span><span class="o">)</span>
</pre></div>
</div>
<p>Notice the absence of the <code class="docutils literal notranslate"><span class="pre">:=</span></code>, the <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">n</span></code> after the colon, the <code class="docutils literal notranslate"><span class="pre">by</span></code> keyword in each case,
and the inductive appeal to <code class="docutils literal notranslate"><span class="pre">fac_pos'</span> <span class="pre">n</span></code>.
It is as though the theorem is a recursive function of <code class="docutils literal notranslate"><span class="pre">n</span></code> and in the inductive step we make
a recursive call.</p>
<p>This style of definition is remarkably flexible.
Lean&#8217;s designers have built in elaborate means of defining recursive functions, and these
extend to doing proofs by induction.
For example, we can define the Fibonacci function with multiple base cases.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">2</span> <span class="bp">=&gt;</span> <span class="n">fib</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;[simp]</span></code> annotation means that the simplifier will use the defining equations.
You can also apply them by writing <code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">[fib]</span></code>.
Below it will be helpful to give a name to the <code class="docutils literal notranslate"><span class="pre">n+2</span></code> case.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">fib_add_two</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fib</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fib</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">fib</span><span class="o">]</span>
</pre></div>
</div>
<p>Using Lean&#8217;s notation for recursive functions, you can carry out proofs by induction on the
natural numbers that mirror the recursive definition of <code class="docutils literal notranslate"><span class="pre">fib</span></code>.
The following example provides an explicit formula for the nth Fibonacci number in terms of
the golden mean, <code class="docutils literal notranslate"><span class="pre">&#966;</span></code>, and its conjugate, <code class="docutils literal notranslate"><span class="pre">&#966;'</span></code>.
We have to tell Lean that we don&#8217;t expect our definitions to generate code because the
arithmetic operations on the real numbers are not computable.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">noncomputable</span> <span class="kn">section</span>
<span class="kn">open</span> <span class="n">Real</span>

<span class="kd">def</span> <span class="n">phi</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="bp">&#8730;</span><span class="mi">5</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span>
<span class="kd">def</span> <span class="n">phi&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">-</span> <span class="bp">&#8730;</span><span class="mi">5</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span>

<span class="kd">theorem</span> <span class="n">phi_sq</span> <span class="o">:</span> <span class="n">phi</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">phi</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">field_simp</span> <span class="o">[</span><span class="n">phi</span><span class="o">]</span>
  <span class="n">ring_nf</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">sq_sqrt</span><span class="o">]</span><span class="bp">;</span> <span class="n">ring</span>

<span class="kd">theorem</span> <span class="n">phi&#39;_sq</span> <span class="o">:</span> <span class="n">phi&#39;</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">phi&#39;</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">field_simp</span> <span class="o">[</span><span class="n">phi&#39;</span><span class="o">]</span>
  <span class="n">ring_nf</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">sq_sqrt</span><span class="o">]</span><span class="bp">;</span> <span class="n">ring</span>

<span class="kd">theorem</span> <span class="n">fib_eq</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">fib</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">phi</span><span class="bp">^</span><span class="n">n</span> <span class="bp">-</span> <span class="n">phi&#39;</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="bp">/</span> <span class="bp">&#8730;</span><span class="mi">5</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">field_simp</span> <span class="o">[</span><span class="n">phi</span><span class="o">,</span> <span class="n">phi&#39;</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">+</span><span class="mi">2</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="n">field_simp</span> <span class="o">[</span><span class="n">fib_eq</span><span class="o">,</span> <span class="n">pow_add</span><span class="o">,</span> <span class="n">phi_sq</span><span class="o">,</span> <span class="n">phi&#39;_sq</span><span class="o">]</span>
      <span class="n">ring</span>

<span class="kd">end</span>
</pre></div>
</div>
<p>Induction proofs involving the Fibonacci function do not have to be of that form.
Below we reproduce the <code class="docutils literal notranslate"><span class="pre">Mathlib</span></code> proof that consecutive Fibonacci numbers are coprime.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">fib_coprime_fib_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat.Coprime</span> <span class="o">(</span><span class="n">fib</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">fib</span><span class="o">,</span> <span class="n">Nat.coprime_add_self_right</span><span class="o">]</span>
      <span class="n">exact</span> <span class="n">ih.symm</span>
</pre></div>
</div>
<p>Using Lean&#8217;s computational interpretation, we can evaluate the Fibonacci numbers.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">fib</span> <span class="mi">6</span>
<span class="k">#eval</span> <span class="n">List.range</span> <span class="mi">20</span> <span class="bp">|&gt;.</span><span class="n">map</span> <span class="n">fib</span>
</pre></div>
</div>
<p>The straightforward implementation of <cite>fib``</cite> is computationally inefficient. In fact, it runs
in time exponential in its argument. (You should think about why.)
In Lean, we can implement the following tail-recursive version, whose running time is linear
in <code class="docutils literal notranslate"><span class="pre">n</span></code>, and prove that it computes the same function.
Notice the <code class="docutils literal notranslate"><span class="pre">generalizing</span></code> keyword in the proof of <code class="docutils literal notranslate"><span class="pre">fib'.aux_eq</span></code>.
It serves to insert a <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">m</span></code> in front of the inductive hypothesis, so that in the induction
step, <code class="docutils literal notranslate"><span class="pre">m</span></code> can take a different value.
You can step through the proof and check that in this case, <code class="docutils literal notranslate"><span class="pre">m</span></code> needs to be instantiated
to <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">+</span> <span class="pre">1</span></code>.
As usual, you can hover over the <code class="docutils literal notranslate"><span class="pre">induction</span></code> keyword to read the documentation.
Notice also the use of <code class="docutils literal notranslate"><span class="pre">erw</span></code> (for &#8220;extended rewrite&#8221;) instead of <code class="docutils literal notranslate"><span class="pre">rw</span></code>.
This is used because to rewrite the goal <code class="docutils literal notranslate"><span class="pre">fib'.aux_eq</span></code>, <code class="docutils literal notranslate"><span class="pre">fib</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">fib</span> <span class="pre">1</span></code>
have to be reduced to <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span></code>, respectively.
The tactic <code class="docutils literal notranslate"><span class="pre">erw</span></code> is simply more aggressive than <code class="docutils literal notranslate"><span class="pre">rw</span></code> in unfolding definitions to
match parameters.
This isn&#8217;t always a good idea; it can waste a lot of time in some cases, so use <code class="docutils literal notranslate"><span class="pre">erw</span></code>
sparingly.</p>
<p>Here is another example of the <code class="docutils literal notranslate"><span class="pre">generalizing</span></code> keyword in use, in the proof of another
identity that is found in <code class="docutils literal notranslate"><span class="pre">Mathlib</span></code>.
An informal proof of the identity can be found [here](<a class="reference external" href="https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers">https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers</a>).
We provide two variants of the formal proof.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">fib_add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">fib</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fib</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">fib</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="n">generalizing</span> <span class="n">m</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
      <span class="n">specialize</span> <span class="n">ih</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">add_assoc</span> <span class="n">m</span> <span class="mi">1</span> <span class="n">n</span><span class="o">,</span> <span class="n">add_comm</span> <span class="mi">1</span> <span class="n">n</span><span class="o">]</span> <span class="n">at</span> <span class="n">ih</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">fib_add_two</span><span class="o">,</span> <span class="n">Nat.succ_eq_add_one</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>
      <span class="n">ring</span>

<span class="kd">theorem</span> <span class="n">fib_add&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">fib</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fib</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">fib</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="mi">0</span>     <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="n">fib_add&#39;</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">add_assoc</span> <span class="n">m</span> <span class="mi">1</span> <span class="n">n</span><span class="o">,</span> <span class="n">add_comm</span> <span class="mi">1</span> <span class="n">n</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">fib_add_two</span><span class="o">,</span> <span class="n">Nat.succ_eq_add_one</span><span class="o">,</span> <span class="n">this</span><span class="o">]</span>
      <span class="n">ring</span>
</pre></div>
</div>
<p>As an exercise, use <code class="docutils literal notranslate"><span class="pre">fib_add</span></code> to prove the following.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">):</span> <span class="o">(</span><span class="n">fib</span> <span class="n">n</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="o">(</span><span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">fib</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">two_mul</span><span class="o">,</span> <span class="n">fib_add</span><span class="o">,</span> <span class="n">pow_two</span><span class="o">,</span> <span class="n">pow_two</span><span class="o">]</span>
</pre></div>
</div>
<p>Lean&#8217;s mechanisms for defining recursive functions are flexible enough to allow arbitrary
recursive calls, as long the complexity of the arguments decrease according to some
well-founded measure.
In the next example, we show that every natural number <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&#8800;</span> <span class="pre">1</span></code> has a prime divisor,
using the fact that if <code class="docutils literal notranslate"><span class="pre">n</span></code> is itself nonzero and not prime, it has a smaller divisor.
(You can check that Mathlib has a theorem of the same name in the <code class="docutils literal notranslate"><span class="pre">Nat</span></code> namespace,
though it has a different proof than the one we give here.)</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="o">(</span><span class="bp">@</span><span class="n">Nat.not_prime_iff_exists_dvd_lt</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">},</span> <span class="mi">2</span> <span class="bp">&#8804;</span> <span class="n">n</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">Nat.Prime</span> <span class="n">n</span> <span class="bp">&#8596;</span> <span class="bp">&#8707;</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&#8739;</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="mi">2</span> <span class="bp">&#8804;</span> <span class="n">m</span> <span class="bp">&#8743;</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">))</span>

<span class="kd">theorem</span> <span class="n">ne_one_iff_exists_prime_dvd</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">n</span> <span class="bp">&#8800;</span> <span class="mi">1</span> <span class="bp">&#8596;</span> <span class="bp">&#8707;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">,</span> <span class="n">p.Prime</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="bp">&#8739;</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">Exists.intro</span> <span class="mi">2</span> <span class="n">Nat.prime_two</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">Nat.not_prime_one</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=&gt;</span> <span class="kd">by</span>
    <span class="k">have</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">n</span><span class="bp">+</span><span class="mi">2</span> <span class="bp">&#8800;</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">omega</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_iff_iff</span><span class="o">,</span> <span class="n">Ne</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">hn</span><span class="o">]</span>
    <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">Nat.Prime</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span>
    <span class="bp">&#183;</span> <span class="n">use</span> <span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">,</span> <span class="n">h</span>
    <span class="bp">&#183;</span> <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&#8804;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">omega</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">Nat.not_prime_iff_exists_dvd_lt</span> <span class="n">this</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span>
      <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">m</span><span class="o">,</span> <span class="n">mdvdn</span><span class="o">,</span> <span class="n">mge2</span><span class="o">,</span> <span class="bp">-</span><span class="o">&#10217;</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&#8800;</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">omega</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ne_one_iff_exists_prime_dvd</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span>
      <span class="n">rcases</span> <span class="n">this</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">p</span><span class="o">,</span> <span class="n">primep</span><span class="o">,</span> <span class="n">pdvdm</span><span class="o">&#10217;</span>
      <span class="n">use</span> <span class="n">p</span><span class="o">,</span> <span class="n">primep</span>
      <span class="n">exact</span> <span class="n">pdvdm.trans</span> <span class="n">mdvdn</span>
</pre></div>
</div>
<p>The line <code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">[ne_one_iff_exists_prime_dvd]</span> <span class="pre">at</span> <span class="pre">this</span></code> is like a magic trick: we are using
the very theorem we are proving in its own proof.
What makes it work is that it is instantiated at <code class="docutils literal notranslate"><span class="pre">m</span></code> and the context has <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">2</span></code>.
Lean can find the hypothesis and use it to show that the induction is well-founded.
Lean is pretty good at figuring out what is decreasing; in this case, the choice of
<code class="docutils literal notranslate"><span class="pre">n</span></code> and the less-than relation is obvious.
We will see later (in a section that has not been written yet) that in more complicated
situations Lean will let you specify an arbitrary measure of complexity.</p>
<p>Sometimes, in a proof, you need to split on cases depending on whether a natural number <code class="docutils literal notranslate"><span class="pre">n</span></code>
is zero or a successor, without requiring an inductive hypothesis in the successor case.
For that, you can use the <code class="docutils literal notranslate"><span class="pre">cases</span></code> and <code class="docutils literal notranslate"><span class="pre">rcases</span></code> tactics.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">zero_lt_of_mul_eq_one</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span><span class="bp">*</span><span class="n">m</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">&#8594;</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases</span> <span class="n">n</span> <span class="bp">&lt;;&gt;</span> <span class="n">cases</span> <span class="n">m</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span><span class="bp">*</span><span class="n">m</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">&#8594;</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rcases</span> <span class="n">m</span> <span class="k">with</span> <span class="o">(</span><span class="n">_</span> <span class="bp">|</span> <span class="n">m</span><span class="o">)</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span>
  <span class="n">rcases</span> <span class="n">n</span> <span class="k">with</span> <span class="o">(</span><span class="n">_</span> <span class="bp">|</span> <span class="n">n</span><span class="o">)</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span>
</pre></div>
</div>
<p>This is a useful trick.
Often you have a theorem about a natural number <code class="docutils literal notranslate"><span class="pre">n</span></code> for which the zero case is easy.
If you case on <code class="docutils literal notranslate"><span class="pre">n</span></code> and take care of the zero case quickly, you are left with the original
goal with <code class="docutils literal notranslate"><span class="pre">n</span></code> replaced by <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</section>
<section id="finsets-and-fintypes">
<span id="id3"></span><h2><span class="section-number">6.2. </span>Finsets and Fintypes<a class="headerlink" href="#finsets-and-fintypes" title="Permalink to this heading">&#61633;</a></h2>
<p>Dealing with finite sets and types in Mathlib can be confusing, because the library offers
multiple ways of handling them. In this section we will discuss one of them.</p>
<p>We have already come across the type <code class="docutils literal notranslate"><span class="pre">Finset</span></code> in <a class="reference internal" href="C05_Elementary_Number_Theory.html#section-induction-and-recursion"><span class="std std-numref">Section 5.2</span></a>
and <a class="reference internal" href="C05_Elementary_Number_Theory.html#section-infinitely-many-primes"><span class="std std-numref">Section 5.3</span></a>.
As the name suggests, an element of type <code class="docutils literal notranslate"><span class="pre">Finset</span> <span class="pre">&#945;</span></code> is a finite set of elements of type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>.
We will call the elements of such a type &#8220;finsets.&#8221;
<code class="docutils literal notranslate"><span class="pre">Finset</span></code> is designed to have a computational interpretation,
and many basic operations on <code class="docutils literal notranslate"><span class="pre">Finset</span> <span class="pre">&#945;</span></code> assume that <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> has decidable equality, which guarantees
that there is an algorithm for testing whether <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code> is an element
of a finset <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">DecidableEq</span> <span class="n">&#945;</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#945;</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s</span>
<span class="k">#check</span> <span class="n">s</span> <span class="bp">&#8745;</span> <span class="n">t</span>

<span class="kd">end</span>
</pre></div>
</div>
<p>If you remove the declaration <code class="docutils literal notranslate"><span class="pre">[DecidableEq</span> <span class="pre">&#945;]</span></code>, Lean will complain on the line
<code class="docutils literal notranslate"><span class="pre">#check</span> <span class="pre">s</span> <span class="pre">&#8745;</span> <span class="pre">t</span></code> because it cannot compute the intersection.
All of the data types that you should expect to be able to compute with
have decidable equality, however,
and f you work classically by opening the <code class="docutils literal notranslate"><span class="pre">Classical</span></code> namespace and
declaring <code class="docutils literal notranslate"><span class="pre">noncomputable</span> <span class="pre">section</span></code>, you can reason about finsets of elements of any type
at all.</p>
<p>Finsets support most of the set-theoretic operations that sets do:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="n">Finset</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">a</span> <span class="bp">&#8745;</span> <span class="n">b</span>
<span class="k">#check</span> <span class="n">a</span> <span class="bp">&#8746;</span> <span class="n">b</span>
<span class="k">#check</span> <span class="n">a</span> <span class="bp">\</span> <span class="n">b</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">&#8709;</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8745;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8746;</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8745;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8746;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8745;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">ext</span> <span class="n">x</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_inter</span><span class="o">,</span> <span class="n">mem_union</span><span class="o">]</span>
  <span class="n">tauto</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8745;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8746;</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8745;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8746;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8745;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">inter_union_distrib_left</span><span class="o">]</span>
</pre></div>
</div>
<p>Note that we have opened the <code class="docutils literal notranslate"><span class="pre">Finset</span></code> namespace,
where theorems specific to finsets are found.
If you step through the last example below, you will see applying <code class="docutils literal notranslate"><span class="pre">ext</span></code>
followed by <code class="docutils literal notranslate"><span class="pre">simp</span></code> reduces the identity to a problem
in propositional logic.
As an exercise, you can try proving some of set identities from
<a class="reference internal" href="C04_Sets_and_Functions.html#sets-and-functions"><span class="std std-numref">Chapter 4</span></a>, transported to finsets.</p>
<p>You have already seen the notation <code class="docutils literal notranslate"><span class="pre">Finset.range</span> <span class="pre">n</span></code> for the
finite set of natural numbers <span class="math notranslate nohighlight">\(\{ 0, 1, \ldots, n-1 \}\)</span>.
<code class="docutils literal notranslate"><span class="pre">Finset</span></code> also allows you to define finite sets by enumerating
the elements:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="o">({</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">}</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">Nat</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">example1</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span> <span class="o">:=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span>
</pre></div>
</div>
<p>There are various ways to get Lean to recognize that order of elements and
duplicates do not matter in a set presented in this way.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="o">({</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">decide</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">({</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">decide</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">({</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">}</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">Finset.pair_comm</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="o">({</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="o">({</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">,</span> <span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">ext</span> <span class="n">i</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">or_comm</span><span class="o">,</span> <span class="n">or_assoc</span><span class="o">,</span> <span class="n">or_left_comm</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="o">({</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">,</span> <span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">ext</span> <span class="n">i</span>
  <span class="n">simp</span>
  <span class="n">tauto</span>
</pre></div>
</div>
<p>You can use <code class="docutils literal notranslate"><span class="pre">insert</span></code> to add a single element to a Finset, and <code class="docutils literal notranslate"><span class="pre">Finset.erase</span></code>
to delete a single element.
Note that <code class="docutils literal notranslate"><span class="pre">erase</span></code> is in the <code class="docutils literal notranslate"><span class="pre">Finset</span></code> namespace, but <code class="docutils literal notranslate"><span class="pre">insert</span></code> is in the root
namespace.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8713;</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">insert</span> <span class="n">a</span> <span class="n">s</span> <span class="bp">|&gt;.</span><span class="n">erase</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
  <span class="n">Finset.erase_insert</span> <span class="n">h</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">insert</span> <span class="n">a</span> <span class="o">(</span><span class="n">s.erase</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
  <span class="n">Finset.insert_erase</span> <span class="n">h</span>
</pre></div>
</div>
<p>In fact, <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2}</span></code> is just notation for <code class="docutils literal notranslate"><span class="pre">insert</span> <span class="pre">0</span> <span class="pre">(insert</span> <span class="pre">1</span> <span class="pre">(singleton</span> <span class="pre">2))</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">set_option</span> <span class="n">pp.notation</span> <span class="n">false</span> <span class="k">in</span>
<span class="k">#check</span> <span class="o">({</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span>
</pre></div>
</div>
<p>Unfortunately, we cannot use set-builder notation with finsets: we can&#8217;t write
an expression like <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">|</span> <span class="pre">Even</span> <span class="pre">x</span> <span class="pre">&#8743;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">5</span> <span class="pre">}</span></code> because Lean can&#8217;t straightforwardly infer that such a set is finite.
However, you can start with a finset and separate the elements you want using <code class="docutils literal notranslate"><span class="pre">Finset.filter</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="n">Even</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">&#8614;</span> <span class="n">Even</span> <span class="n">x</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="mi">3</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">range</span> <span class="mi">10</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="n">Even</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">}</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">decide</span>
</pre></div>
</div>
<p>Mathlib knows that the image of a finset under a function is a finset.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="o">(</span><span class="n">range</span> <span class="mi">5</span><span class="o">)</span><span class="bp">.</span><span class="n">image</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">&#8614;</span> <span class="n">x</span> <span class="bp">*</span> <span class="mi">2</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">range</span> <span class="mi">5</span><span class="o">)</span><span class="bp">.</span><span class="n">image</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">&#8614;</span> <span class="n">x</span> <span class="bp">*</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">range</span> <span class="mi">10</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="n">Even</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">decide</span>
</pre></div>
</div>
<p>Lean also knows that the cartesian product <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">&#215;&#738;</span> <span class="pre">t</span></code> of two finsets is a finset,
and that the powerset of a finset is a finset. (Note that the notation <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">&#215;&#738;</span> <span class="pre">t</span></code>
also works for sets.)</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">s</span> <span class="bp">&#215;&#738;</span> <span class="n">t</span>
<span class="k">#check</span> <span class="n">s.powerset</span>
</pre></div>
</div>
<p>Defining an operation on finsets in terms of their elements is tricky, because any such definition
has to be independent of the order in which the elements are presented.
Of course, you can always define functions by composing existing operations.
Another thing you can do is use <code class="docutils literal notranslate"><span class="pre">Finset.fold</span></code> <em>fold</em> a binary operation over the
elements, provided that the operation is associative and commutative,
since these properties guarantee that the result is independent of the order that
the operation is applied. Finite sums, products, and unions are defined in that way.
In the last example below, <code class="docutils literal notranslate"><span class="pre">biUnion</span></code> stands for &#8220;bounded indexed union.&#8221;
With conventional mathematical notation, the expression would be written
<span class="math notranslate nohighlight">\(\bigcup_{i &#8712; s} g(i)\)</span>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">Finset.fold</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">Int</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">&#8593;</span><span class="n">n</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">range</span> <span class="mi">5</span><span class="o">)</span><span class="bp">.</span><span class="n">fold</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">&#8614;</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="mi">0</span> <span class="n">f</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">range</span> <span class="mi">5</span><span class="o">)</span><span class="bp">.</span><span class="n">fold</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Int</span> <span class="bp">&#8614;</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="mi">0</span> <span class="n">f</span>

<span class="k">#check</span> <span class="bp">&#8721;</span> <span class="n">i</span> <span class="bp">&#8712;</span> <span class="n">range</span> <span class="mi">5</span><span class="o">,</span> <span class="n">i</span><span class="bp">^</span><span class="mi">2</span>
<span class="k">#check</span> <span class="bp">&#8719;</span> <span class="n">i</span> <span class="bp">&#8712;</span> <span class="n">range</span> <span class="mi">5</span><span class="o">,</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">&#8594;</span> <span class="n">Finset</span> <span class="n">Int</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">range</span> <span class="mi">5</span><span class="o">)</span><span class="bp">.</span><span class="n">biUnion</span> <span class="n">g</span>
</pre></div>
</div>
<p>There is a natural principle of induction on finsets: to prove that every finset
has a property, show that the empty set has the property and that the property is
preserved when we add one new element to a finset. (The <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> in <code class="docutils literal notranslate"><span class="pre">&#64;insert</span></code> is need
in the induction step to give names to the parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">s</span></code> because they
have been marked implicit. )</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">Finset.induction</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">DecidableEq</span> <span class="n">&#945;</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span><span class="o">)</span>  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">&#8719;</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">s</span> <span class="n">using</span> <span class="n">Finset.induction_on</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">empty</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="bp">@</span><span class="n">insert</span> <span class="n">a</span> <span class="n">s</span> <span class="n">anins</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">prod_insert</span> <span class="n">anins</span><span class="o">]</span>
      <span class="n">apply</span> <span class="n">mul_ne_zero</span>
      <span class="bp">&#183;</span> <span class="n">apply</span> <span class="n">h</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">mem_insert_self</span>
      <span class="n">apply</span> <span class="n">ih</span>
      <span class="n">intros</span> <span class="n">x</span> <span class="n">xs</span>
      <span class="n">exact</span> <span class="n">h</span> <span class="n">x</span> <span class="o">(</span><span class="n">mem_insert_of_mem</span> <span class="n">xs</span><span class="o">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">s</span></code> is a finset, <code class="docutils literal notranslate"><span class="pre">Finset.Nonempty</span> <span class="pre">s</span></code> is defined to be <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x,</span> <span class="pre">x</span> <span class="pre">&#8712;</span> <span class="pre">s</span></code>.
You can use classical choice to pick an element of a nonempty finset. Similarly,
the library defines <code class="docutils literal notranslate"><span class="pre">Finset.toList</span> <span class="pre">s</span></code> which uses choice to pick the elements of
<code class="docutils literal notranslate"><span class="pre">s</span></code> in some order.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">noncomputable</span> <span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s.Nonempty</span><span class="o">)</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="o">:=</span> <span class="n">Classical.choose</span> <span class="n">h</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s.Nonempty</span><span class="o">)</span> <span class="o">:</span> <span class="n">Classical.choose</span> <span class="n">h</span> <span class="bp">&#8712;</span> <span class="n">s</span> <span class="o">:=</span>
   <span class="n">Classical.choose_spec</span> <span class="n">h</span>

<span class="kd">noncomputable</span> <span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="n">&#8469;</span> <span class="o">:=</span> <span class="n">s.toList</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s.toList</span> <span class="bp">&#8596;</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">mem_toList</span>
</pre></div>
</div>
<p>You can use <code class="docutils literal notranslate"><span class="pre">Finset.min</span></code> and <code class="docutils literal notranslate"><span class="pre">Finset.max</span></code> to choose the minimum or maximum element
of a finset of elements of a linear order, and similarly you can use <code class="docutils literal notranslate"><span class="pre">Finset.sup</span></code>
and <code class="docutils literal notranslate"><span class="pre">Finset.max</span></code> with finstes of elements of a lattice, but there is a catch.
What should the minimum element of an empty finset be?
You can check that the primed versions of the functions below add a precondition
that the finset is nonempty.
The non-primed versions <code class="docutils literal notranslate"><span class="pre">Finset.min</span></code> and <code class="docutils literal notranslate"><span class="pre">Finset.max</span></code>
add a top or bottom element, respectively, to handle the case where the finset is empty,
and the non-primed versions <code class="docutils literal notranslate"><span class="pre">Finset.inf</span></code> and <code class="docutils literal notranslate"><span class="pre">Finset.sup</span></code> assume that
the lattice comes equipped with a top or bottom element, respectively.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">Finset.min</span>
<span class="k">#check</span> <span class="n">Finset.min&#39;</span>
<span class="k">#check</span> <span class="n">Finset.max</span>
<span class="k">#check</span> <span class="n">Finset.max&#39;</span>
<span class="k">#check</span> <span class="n">Finset.inf</span>
<span class="k">#check</span> <span class="n">Finset.inf&#39;</span>
<span class="k">#check</span> <span class="n">Finset.sup</span>
<span class="k">#check</span> <span class="n">Finset.sup&#39;</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">Finset.Nonempty</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">}</span> <span class="o">:=</span> <span class="o">&#10216;</span><span class="mi">6</span><span class="o">,</span> <span class="kd">by</span> <span class="n">trivial</span><span class="o">&#10217;</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Finset.min&#39;</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">}</span> <span class="o">&#10216;</span><span class="mi">6</span><span class="o">,</span> <span class="kd">by</span> <span class="n">trivial</span><span class="o">&#10217;</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">trivial</span>
</pre></div>
</div>
<p>One of the most important features of finsets is that each one has a finite cardinality.
The next section is all about reasoning about cardinality.</p>
<p>When formalizing mathematics, one often has to make a decision as to whether to express
one&#8217;s definitions and theorems in terms of sets or types.
Restricting attention to an entire type often simplifies notation and proofs, but working
with subsets of a type can be more flexible.
The type-based analogue of a finset is a <em>fintype</em>, that is, a type <code class="docutils literal notranslate"><span class="pre">Fintype</span> <span class="pre">&#945;</span></code> for some
<code class="docutils literal notranslate"><span class="pre">&#945;</span></code>.
By definition, a fintype is just a data type that comes equipped with a finset <code class="docutils literal notranslate"><span class="pre">univ</span></code> that
contains all its elements.
<code class="docutils literal notranslate"><span class="pre">Fintype.card</span> <span class="pre">&#945;</span></code> is equal to the cardinality of the corresponding finset.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">Fintype.card</span> <span class="n">&#945;</span> <span class="bp">=</span> <span class="o">(</span><span class="n">Finset.univ</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#945;</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
<p>We have already seen a prototypical example of a fintype, namely, the types <code class="docutils literal notranslate"><span class="pre">Fin</span> <span class="pre">n</span></code> for
each <code class="docutils literal notranslate"><span class="pre">n</span></code>.
But Lean also recognizes that the fintypes are closed under operations like the product operation.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">Fintype.card</span> <span class="o">(</span><span class="n">Fin</span> <span class="mi">5</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Fintype.card</span> <span class="o">((</span><span class="n">Fin</span> <span class="mi">5</span><span class="o">)</span> <span class="bp">&#215;</span> <span class="o">(</span><span class="n">Fin</span> <span class="mi">3</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">15</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>
</pre></div>
</div>
<p>Any element <code class="docutils literal notranslate"><span class="pre">s</span></code> of <code class="docutils literal notranslate"><span class="pre">Finset</span> <span class="pre">&#945;</span></code> can be coercied to a type <code class="docutils literal notranslate"><span class="pre">(&#8593;s</span> <span class="pre">:</span> <span class="pre">Finset</span> <span class="pre">&#945;)</span></code>, namely,
the subtype of elements of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> that are contained in <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variable</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8593;</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">Fintype.card</span> <span class="bp">&#8593;</span><span class="n">s</span> <span class="bp">=</span> <span class="n">s.card</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>
</pre></div>
</div>
<p>Lean and Mathlib use <em>type class inference</em> to track the additional structure on fintypes,
namely, the universal finset that contains all the elements.
In other words, you can think of a fintype as an algebraic structure equipped with that
extra data.
Chapter <a class="reference internal" href="C07_Structures.html#structures"><span class="std std-numref">Chapter 7</span></a> explains how this works.</p>
</section>
<section id="counting-arguments">
<span id="id4"></span><h2><span class="section-number">6.3. </span>Counting Arguments<a class="headerlink" href="#counting-arguments" title="Permalink to this heading">&#61633;</a></h2>
<p>Calculating cardinality.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variable</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">Fintype</span> <span class="n">&#945;</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">Fintype.card</span> <span class="o">(</span><span class="n">Fin</span> <span class="n">n</span> <span class="bp">&#8594;</span> <span class="n">&#945;</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">Fintype.card</span> <span class="n">&#945;</span><span class="o">)</span><span class="bp">^</span><span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">Fintype.card</span> <span class="o">(</span><span class="n">Mathlib.Vector</span> <span class="n">&#945;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">Fintype.card</span> <span class="n">&#945;</span><span class="o">)</span><span class="bp">^</span><span class="n">n</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span>
</pre></div>
</div>
<p>Calculating cardinality.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">Disjoint</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&#8805;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">card</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span> <span class="bp">&#8746;</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">image</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="bp">&#8614;</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">card_union_of_disjoint</span><span class="o">]</span>
  <span class="bp">&#183;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">card_range</span><span class="o">,</span> <span class="n">card_image_of_injective</span><span class="o">]</span>
    <span class="bp">&#183;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">card_range</span><span class="o">]</span><span class="bp">;</span> <span class="n">omega</span>
    <span class="n">apply</span> <span class="n">add_right_injective</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">disjoint_iff_ne</span><span class="o">]</span>
  <span class="n">simp</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">i</span> <span class="n">j</span><span class="bp">;</span> <span class="n">omega</span>
</pre></div>
</div>
<p>Calculating cardinality.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">card</span> <span class="o">((</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">&#215;&#738;</span> <span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">p</span> <span class="bp">=&gt;</span> <span class="n">p.1</span> <span class="bp">&lt;</span> <span class="n">p.2</span><span class="o">))</span> <span class="bp">=</span>
    <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">&#215;&#738;</span> <span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">p</span> <span class="bp">=&gt;</span> <span class="n">p.1</span> <span class="bp">&lt;</span> <span class="n">p.2</span><span class="o">)</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">biUnion</span> <span class="o">(</span><span class="k">fun</span> <span class="n">j</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">range</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">image</span> <span class="k">fun</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">Finset.ext_iff</span><span class="o">,</span> <span class="n">Prod.ext_iff</span><span class="o">,</span> <span class="bp">@</span><span class="n">and_left_comm</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">),</span>
        <span class="n">iff_true_intro</span> <span class="n">lt_trans</span><span class="o">]</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">Finset.card_biUnion</span><span class="o">]</span><span class="bp">;</span> <span class="n">swap</span>
  <span class="bp">&#183;</span> <span class="n">intro</span> <span class="n">x</span> <span class="n">_</span> <span class="n">y</span> <span class="n">_</span> <span class="n">xney</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">disjoint_iff_ne</span><span class="o">,</span> <span class="n">xney</span><span class="o">]</span>
  <span class="n">transitivity</span> <span class="o">(</span><span class="bp">&#8721;</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">i</span><span class="o">)</span>
  <span class="bp">&#183;</span> <span class="n">congr</span><span class="bp">;</span> <span class="n">ext</span> <span class="n">i</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Finset.card_image_of_injective</span><span class="o">,</span> <span class="n">card_range</span><span class="o">]</span>
    <span class="n">intros</span> <span class="n">i1</span> <span class="n">i2</span><span class="bp">;</span> <span class="n">simp</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">Finset.sum_range_id</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">]</span>
</pre></div>
</div>
<p>An example from Bhavik Mehta.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="n">Classical</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">Finset.sum_boole</span>

<span class="kd">theorem</span> <span class="n">doubleCounting</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#946;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_left</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="mi">3</span> <span class="bp">&#8804;</span> <span class="n">card</span> <span class="o">(</span><span class="n">t.filter</span> <span class="o">(</span><span class="n">r</span> <span class="n">a</span> <span class="bp">&#183;</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">h_right</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">b</span> <span class="bp">&#8712;</span> <span class="n">t</span><span class="o">,</span> <span class="n">card</span> <span class="o">(</span><span class="n">s.filter</span> <span class="o">(</span><span class="n">r</span> <span class="bp">&#183;</span> <span class="n">b</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="mi">3</span> <span class="bp">*</span> <span class="n">s.card</span> <span class="bp">&#8804;</span> <span class="n">t.card</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">calc</span>
    <span class="mi">3</span> <span class="bp">*</span> <span class="n">s.card</span> <span class="bp">=</span> <span class="bp">&#8721;</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="mi">3</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sum_const_nat</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span>
    <span class="n">_</span> <span class="bp">&#8804;</span> <span class="bp">&#8721;</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">t.filter</span> <span class="o">(</span><span class="n">r</span> <span class="n">a</span> <span class="bp">&#183;</span><span class="o">))</span><span class="bp">.</span><span class="n">card</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="n">exact</span> <span class="n">sum_le_sum</span> <span class="n">h_left</span>
    <span class="n">_</span> <span class="bp">=</span> <span class="bp">&#8721;</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="bp">&#8721;</span> <span class="n">b</span> <span class="bp">&#8712;</span> <span class="n">t</span><span class="o">,</span> <span class="k">if</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="n">congr</span><span class="bp">;</span> <span class="n">simp</span>
    <span class="n">_</span> <span class="bp">=</span> <span class="bp">&#8721;</span> <span class="n">b</span> <span class="bp">&#8712;</span> <span class="n">t</span><span class="o">,</span> <span class="bp">&#8721;</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="k">if</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="n">exact</span> <span class="n">sum_comm</span>
    <span class="n">_</span> <span class="bp">=</span> <span class="bp">&#8721;</span> <span class="n">b</span> <span class="bp">&#8712;</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">s.filter</span> <span class="o">(</span><span class="n">r</span> <span class="bp">&#183;</span> <span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="n">card</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">sum_boole</span><span class="o">,</span> <span class="n">Nat.cast_id</span><span class="o">]</span>
    <span class="n">_</span> <span class="bp">=</span> <span class="bp">&#8721;</span> <span class="n">b</span> <span class="bp">&#8712;</span> <span class="n">t</span><span class="o">,</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
        <span class="c1">-- congr; ext b; apply h_right</span>
        <span class="n">apply</span> <span class="n">Finset.sum_congr</span> <span class="n">rfl</span> <span class="n">h_right</span>
    <span class="n">_</span> <span class="bp">&#8804;</span> <span class="n">t.card</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>
</pre></div>
</div>
<p>An exercise from Bhavik. Also: replace = by &#8804; in the previous theorem.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">Nat.coprime_self_add_one</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat.Coprime</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">coprime_self_add_right</span><span class="o">,</span>
  <span class="n">coprime_one_right_eq_true</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Finset</span> <span class="n">&#8469;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A.card</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hA&#39;</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">&#8838;</span> <span class="n">Finset.range</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span> <span class="o">:</span>
    <span class="bp">&#8707;</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8743;</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">A</span> <span class="bp">&#8743;</span> <span class="n">Nat.Coprime</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="C05_Elementary_Number_Theory.html" class="btn btn-neutral float-left" title="5. Elementary Number Theory" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="C07_Structures.html" class="btn btn-neutral float-right" title="7. Structures" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Jeremy Avigad, Patrick Massot.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>